// @flow strict

const { BrowserWindow, screen } = require('electron');
const NativeExtension = require('bindings')('NativeExtension');

const isDarwin = process.platform === 'darwin';
const isWindows = process.platform === 'win32';

// Winuser.h resizing hook and messages:
// https://docs.microsoft.com/en-us/windows/win32/winmsg/wm-sizing
const WM_SIZING = 0x0214;
const WM_SIZING_MSG = {
  LEFT: 1,
  RIGHT: 2,
  TOP: 3,
  TOPLEFT: 4,
  TOPRIGHT: 5,
  BOTTOM: 6,
  BOTTOMLEFT: 7,
  BOTTOMRIGHT: 8,
};

class Panel {
  _isPanel = false;
  _browserWindow = null;
  _aspectRatio = null;
  _resizeDirection = null;
  _focusable = false;

  constructor(options) {
    const webPreferences =
      options && options.webPreferences ? options.webPreferences : {};
    const _options = {
      focusable: true,
      ...options,
      show: false,
      webPreferences: {
        ...webPreferences,
        nodeIntegration: false,
      },
    };
    this._browserWindow = new BrowserWindow(_options);

    // BrowserWindow.setAspectRatio() is not implemented for Windows, use
    // custom resize handler to apply aspectRatio until that PR got accepted:
    // https://github.com/electron/electron/pull/18306
    if (isWindows) {
      this._handleWillResize = this._handleWillResize.bind(this);
      this._browserWindow.on('will-resize', this._handleWillResize);
      this._browserWindow.hookWindowMessage(WM_SIZING, wParam => {
        this._resizeDirection = wParam.readUIntBE(0, 1);
      });
    }

    NativeExtension.MakeControls(this.getNativeWindowHandle());
    NativeExtension.MakeVibrant(this.getNativeWindowHandle());
    this.setFocusable(_options.focusable);
    if (options.show) {
      this.show();
    }
  }

  get webContents() {
    return this._browserWindow.webContents;
  }

  getBrowserWindow() {
    return this._browserWindow;
  }

  getNativeWindowHandle() {
    return this._browserWindow.getNativeWindowHandle();
  }

  getBounds() {
    return this._browserWindow.getBounds();
  }

  on(...args) {
    this._browserWindow.on(...args);
  }

  once(...args) {
    this._browserWindow.once(...args);
  }

  removeListener(...args) {
    this._browserWindow.removeListener(...args);
  }

  loadURL(...args) {
    return this._browserWindow.loadURL(...args);
  }

  // Brings window to the front and sets focus on it.
  show(animate) {
    if (isDarwin) {
      NativeExtension.Show(this.getNativeWindowHandle(), !!animate, true);
    } else {
      this._browserWindow.show();
    }
  }

  // Brings window to the front, but doesn't set focus on it.
  showInactive(animate) {
    if (isDarwin) {
      NativeExtension.Show(this.getNativeWindowHandle(), !!animate, false);
    } else {
      this._browserWindow.showInactive();
      this._browserWindow.moveTop();
    }
  }

  hide(animate) {
    animate = animate || false;
    if (isDarwin) {
      return NativeExtension.Hide(this.getNativeWindowHandle(), animate);
    } else {
      this._browserWindow.hide();
    }
  }

  close(animate) {
    animate = animate || false;
    if (this._isPanel) {
      NativeExtension.ClosePanel(this.getNativeWindowHandle(), animate);
    } else {
      this._browserWindow.close();
    }
  }

  minimize() {
    return this._browserWindow.minimize();
  }

  maximize() {
    return this._browserWindow.maximize();
  }

  unmaximize() {
    return this._browserWindow.unmaximize();
  }

  isFullScreen() {
    return this._browserWindow.isFullScreen();
  }

  setFullScreen(value) {
    return this._browserWindow.setFullScreen(value);
  }

  isAlwaysOnTop() {
    return this._browserWindow.isAlwaysOnTop();
  }

  setAlwaysOnTop(value) {
    this._browserWindow.setAlwaysOnTop(value);
    if (isWindows) {
      NativeExtension.SetAlwaysOnTop(this.getNativeWindowHandle(), !!value);
    } else if (this._isPanel) {
      NativeExtension.SyncPanel(this.getNativeWindowHandle(), false);
    }
  }

  isMinimizable() {
    return this._browserWindow.isMinimizable();
  }

  isMinimized() {
    return this._browserWindow.isMinimized();
  }

  isMaximized() {
    return this._browserWindow.isMaximized();
  }

  setMinimizable(value) {
    return this._browserWindow.setMinimizable(value);
  }

  setMaximizable(value) {
    return this._browserWindow.setMaximizable(value);
  }

  setFullScreenable(value) {
    return this._browserWindow.setFullScreenable(value);
  }

  restore() {
    return this._browserWindow.restore();
  }

  destroy() {
    if (this._isPanel) {
      NativeExtension.ClosePanel(this.getNativeWindowHandle(), false);
    }
    if (isWindows) {
      this._browserWindow.removeListener('will-resize', this._handleWillResize);
      this._browserWindow.unhookWindowMessage(WM_SIZING);
    }
    this._browserWindow.destroy();
  }

  isDestroyed() {
    return this._browserWindow.isDestroyed();
  }

  setBounds(bounds, animate) {
    animate = animate || false;

    // Electron window is pushed down to the top of the screen border if negative Y coordinate is provided in MacOS, but not in Windows.
    // Make sure that negative Y coordinate is never set, so window is not positioned too high and part of the content is not hidden.
    const windowBounds = {
      ...bounds,
    };
    if (windowBounds.y != null && windowBounds.y < 0) {
      windowBounds.y = 0;
    }

    this._browserWindow.setBounds(windowBounds, animate && !this._isPanel);
    if (this._isPanel) {
      NativeExtension.SyncPanel(this.getNativeWindowHandle(), animate);
    }
  }

  setPosition(x, y, animate) {
    animate = animate || false;

    // Electron window is pushed down to the top of the screen border if negative Y coordinate is provided in MacOS, but not in Windows.
    // Make sure that negative Y coordinate is never set, so window is not positioned too high and part of the content is not hidden.
    let yCoord = y;
    if (yCoord != null && yCoord < 0) {
      yCoord = 0;
    }
    this._browserWindow.setPosition(x, yCoord, animate && !this._isPanel);
    if (this._isPanel) {
      NativeExtension.SyncPanel(this.getNativeWindowHandle(), animate);
    }
  }

  setSize(w, h, animate) {
    animate = animate || false;
    this._browserWindow.setSize(w, h, animate && !this._isPanel);
    if (this._isPanel) {
      NativeExtension.SyncPanel(this.getNativeWindowHandle(), animate);
    }
  }

  setMinimumSize(minWidth, minHeight) {
    this._browserWindow.setMinimumSize(minWidth, minHeight);
    if (this._isPanel) {
      NativeExtension.SyncPanel(this.getNativeWindowHandle(), false);
    }
  }

  setResizable(value) {
    this._browserWindow.setResizable(value);
    if (this._isPanel) {
      NativeExtension.SyncPanel(this.getNativeWindowHandle(), false);
    }
    if (isWindows && value) {
      // Fixes window style to make it snappable again.
      NativeExtension.MakeResizable(this.getNativeWindowHandle());
    }
  }

  setAspectRatio(value) {
    this._aspectRatio = value;
    this._browserWindow.setAspectRatio(value);
    if (this._isPanel) {
      NativeExtension.SyncPanel(this.getNativeWindowHandle(), false);
    }
  }

  isPanel() {
    return this._isPanel;
  }

  makePanel() {
    if (isDarwin && !this._isPanel) {
      NativeExtension.MakePanel(this.getNativeWindowHandle());
      this._isPanel = true;
    }
  }

  makeWindow() {
    if (isDarwin && this._isPanel) {
      NativeExtension.MakeWindow(this.getNativeWindowHandle());
      this._isPanel = false;
    }
  }

  isFocusable() {
    return this._focusable;
  }

  setFocusable(value) {
    this._focusable = !!value;
    this._browserWindow.setFocusable(!!value);
    if (isDarwin) {
      NativeExtension.SetFocusable(this.getNativeWindowHandle(), !!value);
    }
  }

  setVisibleOnAllWorkspaces(...args) {
    this._browserWindow.setVisibleOnAllWorkspaces(...args);
  }

  setAppDetails(options) {
    this._browserWindow.setAppDetails(options);
  }

  initiateWindowMove() {
    if (isWindows) {
      NativeExtension.InitiateWindowMove(this.getNativeWindowHandle());
    }
  }

  // On Windows, a window can be "snapped" to the edges/corners of the screen.
  // When user moves the window and the mouse cursor hits the edge of the screen
  // or one of the corners -- window gets snapped to that edge/corner.
  isSnapped() {
    if (isDarwin) return false;
    if (this.isFullScreen() || this.isMaximized()) return false;

    const panelBounds = this.getBounds();
    const screenWorkArea = screen.getDisplayMatching(panelBounds).workArea;

    const approximatelyEqual = (a, b) => Math.abs(a - b) <= 1;

    return (
      // left edge
      (panelBounds.x - screenWorkArea.x === 0 &&
        panelBounds.y - screenWorkArea.y === 0 &&
        panelBounds.height === screenWorkArea.height &&
        approximatelyEqual(panelBounds.width, screenWorkArea.width / 2)) ||
      // right edge
      (panelBounds.x - screenWorkArea.x ===
        screenWorkArea.width - panelBounds.width &&
        panelBounds.y - screenWorkArea.y === 0 &&
        panelBounds.height === screenWorkArea.height &&
        approximatelyEqual(panelBounds.width, screenWorkArea.width / 2)) ||
      // top-left corner
      (panelBounds.x - screenWorkArea.x === 0 &&
        panelBounds.y - screenWorkArea.y === 0 &&
        approximatelyEqual(panelBounds.height, screenWorkArea.height / 2) &&
        approximatelyEqual(panelBounds.width, screenWorkArea.width / 2)) ||
      // top-right corner
      (panelBounds.x - screenWorkArea.x ===
        screenWorkArea.width - panelBounds.width &&
        panelBounds.y - screenWorkArea.y === 0 &&
        approximatelyEqual(panelBounds.height, screenWorkArea.height / 2) &&
        approximatelyEqual(panelBounds.width, screenWorkArea.width / 2)) ||
      // bottom-left corner
      (panelBounds.x - screenWorkArea.x === 0 &&
        panelBounds.y - screenWorkArea.y ===
          screenWorkArea.height - panelBounds.height &&
        approximatelyEqual(panelBounds.height, screenWorkArea.height / 2) &&
        approximatelyEqual(panelBounds.width, screenWorkArea.width / 2)) ||
      // bottom-right corner
      (panelBounds.x - screenWorkArea.x ===
        screenWorkArea.width - panelBounds.width &&
        panelBounds.y - screenWorkArea.y ===
          screenWorkArea.height - panelBounds.height &&
        approximatelyEqual(panelBounds.height, screenWorkArea.height / 2) &&
        approximatelyEqual(panelBounds.width, screenWorkArea.width / 2))
    );
  }

  _handleWillResize(event, bounds) {
    if (!this._aspectRatio || !this._resizeDirection) return;

    event.preventDefault();

    const rawBounds = screen.screenToDipRect(this._browserWindow, bounds);
    const newBounds = { ...rawBounds };

    const [minWidth, minHeight] = this._browserWindow.getMinimumSize();
    if (newBounds.width < minWidth || newBounds.height < minHeight) return;

    const getHeightFromWidth = width =>
      Math.max(minHeight, Math.floor(width / this._aspectRatio));
    const getWidthFromHeight = height =>
      Math.max(minWidth, Math.floor(height * this._aspectRatio));

    // Resize the window.
    switch (this._resizeDirection) {
      case WM_SIZING_MSG.LEFT:
      case WM_SIZING_MSG.RIGHT:
        newBounds.height = getHeightFromWidth(rawBounds.width);
        break;
      case WM_SIZING_MSG.TOP:
      case WM_SIZING_MSG.BOTTOM:
        newBounds.width = getWidthFromHeight(rawBounds.height);
        break;
      case WM_SIZING_MSG.BOTTOMLEFT:
      case WM_SIZING_MSG.BOTTOMRIGHT:
      case WM_SIZING_MSG.TOPLEFT:
      case WM_SIZING_MSG.TOPRIGHT:
        const widthMagnitude =
          rawBounds.width * getHeightFromWidth(rawBounds.width);
        const heightMagnitude =
          rawBounds.height * getWidthFromHeight(rawBounds.height);
        if (widthMagnitude > heightMagnitude) {
          newBounds.height = getHeightFromWidth(rawBounds.width);
        } else {
          newBounds.width = getWidthFromHeight(rawBounds.height);
        }
        break;
      default:
    }

    // Move the window.
    switch (this._resizeDirection) {
      case WM_SIZING_MSG.TOPLEFT:
        newBounds.x += rawBounds.width - newBounds.width;
        newBounds.y += rawBounds.height - newBounds.height;
        break;
      case WM_SIZING_MSG.TOPRIGHT:
        newBounds.y += rawBounds.height - newBounds.height;
        break;
      case WM_SIZING_MSG.BOTTOMLEFT:
        newBounds.x += rawBounds.width - newBounds.width;
        break;
      default:
    }

    // Do not resize the window more than screen bounds allow, otherwise Windows
    // would resize only the dimension that fits in the screen and the window
    // would lose its configured aspect ratio.
    const screenBounds = screen.getDisplayMatching(
      this._browserWindow.getBounds(),
    ).bounds;
    if (
      newBounds.width > screenBounds.width ||
      newBounds.height > screenBounds.height
    ) {
      return;
    }

    this._browserWindow.setBounds(newBounds);
  }
}

module.exports = { Panel };
